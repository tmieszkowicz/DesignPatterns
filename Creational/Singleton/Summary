# Summary

## Benefits

1. Resource Management (especially true for resource-heavy operations)
1. Controlled Access
1. Consistent State
1. Thread Safety
1. Lazy Initialization

## Drawbacks

1. Hidden Dependencies

    ```cs
    new ServiceA().Foo();

    class ServiceA
    {
        public void Foo()
        {
            Logger.Instance.Log("asdfasdf");
        }
    }
    ```

    `ServiceA` has a hidden dependency on the `Logger`.

    **Solution**: Use DI - making the dependencies explicit.

    ```cs
    new ServiceA(Logger.Instance).Foo();

    class ServiceA(Logger logger)
    {
        public void Foo()
        {
            logger.Log("asdfasdf");
        }
    }
    ```

1. Testing Challenges

    ```cs
    // hard to mock the `Logger`
    class ServiceA
    {
        public void Foo()
        {
            Logger.Instance.Log("asdfasdf");
        }
    }
    ```

    ```cs
    // still hard to mock the `Logger` since the Logger encapsulates initialization
    class ServiceA(Logger logger)
    {
        public void Foo()
        {
            logger.Log("asdfasdf");
        }
    }
    ```

    **Solution**: Inject an interface.

    ```cs
    class ServiceA(ILogger logger)
    {
        public void Foo()
        {
            logger.Log("asdfasdf");
        }
    }
    ```

    **Solution**: Create a wrapper.

    ```cs
    class ServiceA(Wrapper wrapper)
    {
        public void Foo()
        {
            wrapper.Log("asdfasdf");
        }
    }
    ```

1. Tight coupling
1. Single Point of Failure
